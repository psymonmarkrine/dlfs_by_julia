# 3章 ニューラルネットワーク

前章ではパーセプトロンについて学びましたが、パーセプトロンについては良いニュースと悪いニュースがありました。  
～  

## 3.1 パーセプトロンからニューラルネットワークへ
### 3.1.1 ニューラルネットワークの例
### 3.1.2 パーセプトロンの復習
### 3.1.3 活性化関数の登場
## 3.2 活性化関数
### 3.2.1 シグモイド関数
### 3.2.2 ステップ関数の実装

ここではJuliaを使ってステップ関数をグラフで表します。  
～  

```julia
function step_function(x)
    if x > 0
        return 1
    else
        return 0
    end
end
```

この実装は単純で分かりやすいのですが、引数の`x`は実数しか入力することができません。  
つまり、`step_function(3.0)`といった使い方はできますが、配列を引数に取るような使い方──たとえば、`step_function([1.0, 2.0])`のような使い方──はできないのです。  
しかし、[1.5.2節](./md/ch01.md#152-単純なグラフ描画)の内容を思い出してください。  

> これはsin関数がスカラ値に対して作用する関数であるためです。  
> このような関数を配列の各要素を対象に実行したい場合は関数名と引数の間に`.`を入れ、`sin.(x)`とすることで実行することができます。  

この関数も同様で、`step_function.([1.0, 2.0])`とすることで動作させることができます。  

ですが、書籍ではPythonの型変換について記載されるのでそれをもう少しなぞって実装します。  
Juliaでは関数名の後に`.`を付けることで関数のブロードキャストができるため、関数の配列への対応はしません。  
しかし、Juliaでは型の推論を行わせないように工夫して記述することで実行速度を早くすることができることと、さらに入力値や返り値など計算に用いられる一連の型が一致していると都合がよいため、型を変換されるように実装します。  

```julia
function step_function(x)
    return typeof(x)(x > 0)
end
```

上の関数はたったの1行ですが、Juliaの便利な”トリック”を使っているため、少しわかりにくいかもしれません。  
ここでは、どのようなトリックを使っているのか、次のJulia REPLの例を見ながら説明します。  
次の例では、`x`という配列を用意し、その配列に対して不等号による演算を行います。  

```julia
julia> x = [-1.0, 1.0, 2.0]
3-element Vector{Float64}:
 -1.0
  1.0
  2.0

julia> y = x > 0
ERROR: MethodError: no method matching isless(::Int64, ::Vector{Float64})
Closest candidates are:
  isless(::AbstractVector{T} where T, ::AbstractVector{T} where T) at abstractarray.jl:1989
  isless(::Any, ::Missing) at missing.jl:88
  isless(::Missing, ::Any) at missing.jl:87
  ...
Stacktrace:
 [1] <(x::Int64, y::Vector{Float64})
   @ Base .\operators.jl:279
 [2] >(x::Vector{Float64}, y::Int64)
   @ Base .\operators.jl:305
 [3] top-level scope
   @ REPL[2]:1

julia> y = x .> 0
3-element BitVector:
 0
 1
 1
```

配列に対して不等号の演算を行う場合も[同様](./md/ch01.md#137-ブロードキャスト)で、演算子の前に`.`を付けます。  
> 算術演算を行う際に各演算子の前に`.`（ドット）を付けるとブロードキャスト演算子として扱われます。

そうすると各要素に対して不等号の演算が行われ、BitVectorが生成されます。  

ここでは、`x`という配列の要素に対して0より大きい要素は1に、0以下の場合は0に変換され、新しい配列`y`が生成されます。  

さて、私たちの望むステップ関数は、0か1の「`x`と同じ型」を出力する関数です。  
そのため、配列`y`の型をBitVectorからxの配列の型に変換します。  

```julia
julia> typeof(x)
Vector{Float64} (alias for Array{Float64, 1})

julia> typeof(x)(y)
3-element Vector{Float64}:
 0.0
 1.0
 1.0
```

以前示した通り、`typeof()`関数を用いることで変数の型を求めることができます。  
`typeof()`関数で取得した型に入力することで変換することができます。  

関数自体を配列に対応させることもできますが、`.`を用いることでブロードキャストができることを覚えておけば、関数を作成する際にはそのような心配をする必要はなくなります。  
（詳細は省きますが、スカラ値のみに対応した形で記述して関数名の後に`.`を付けて実行した場合のほうが動作も早くなります。）  
以上が、ステップ関数の実装で使われるJuliaの”トリック”でした。  

### 3.2.3 ステップ関数のグラフ

それでは、上で定義したステップ関数をグラフで表してみましょう。  
そのために、パッケージの`Plots`を使用します。  

```julia
using Plots

function step_function(x)
    return typeof(x)(x > 0)
end

X = range(-5.0, 5.0, step=0.1)
Y = step_function.(X)
plot(X, Y, leg = false)
plot!(ylims = (-0.1, 1.1))  # y軸の範囲を指定
```

～  
この`x`、`y`配列をプロットすると、結果は次の**図3－6**のようになります。  

![fig3-6](../image/ch03/fig03-06.png)  
図3-6　ステップ関数のグラフ  

～  
